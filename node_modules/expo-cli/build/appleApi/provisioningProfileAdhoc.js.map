{"version":3,"file":"provisioningProfileAdhoc.js","names":["uniqueItems","items","set","Set","registerMissingDevicesAsync","context","udids","allIosProfileDevices","Device","getAllIOSProfileDevicesAsync","alreadyAdded","filter","device","includes","attributes","udid","alreadyAddedUdids","map","i","Promise","all","createAsync","name","push","findProfileByBundleIdAsync","bundleId","certSerialNumber","expoProfiles","getProfilesForBundleIdAsync","profile","profileType","ProfileType","IOS_APP_ADHOC","startsWith","profileState","ProfileState","EXPIRED","expoProfilesWithCertificate","certificates","getCertificatesAsync","some","cert","serialNumber","sort","sortByExpiration","length","didUpdate","distributionCertificate","getDistributionCertificateAync","CommandError","regenerateAsync","a","b","Date","expirationDate","getTime","findProfileByIdAsync","profileId","profiles","find","id","manageAdHocProfilesAsync","devices","existingProfile","results","deviceUdidsInProfile","Boolean","allDeviceUdids","hasEqualUdids","every","isValid","result","profileName","provisioningProfileId","provisioningProfile","profileContent","updatedProfile","bundleIdItem","getBundleIdForIdentifierAsync","newProfile","Profile","now","didCreate","createOrReuseAdhocProvisioningProfileAsync","authCtx","bundleIdentifier","distCertSerialNumber","spinner","ora","start","getRequestContext","adhocProvisioningProfile","succeed","teamId","team","teamName","error","fail","ProvisioningProfileAdhocManager","constructor","ctx","createOrReuse"],"sources":["../../src/appleApi/provisioningProfileAdhoc.ts"],"sourcesContent":["import { Device, Profile, ProfileState, ProfileType, RequestContext } from '@expo/apple-utils';\n\nimport CommandError from '../CommandError';\nimport { ora } from '../utils/ora';\nimport { AppleCtx, getRequestContext } from './authenticate';\nimport { getBundleIdForIdentifierAsync, getProfilesForBundleIdAsync } from './bundleId';\nimport { getDistributionCertificateAync } from './distributionCert';\nimport { ProvisioningProfile } from './provisioningProfile';\n\ninterface ProfileResults {\n  didUpdate?: boolean;\n  didCreate?: boolean;\n  profileName?: string;\n  provisioningProfileId: string;\n  provisioningProfile: any;\n}\n\nfunction uniqueItems<T = any>(items: T[]): T[] {\n  const set = new Set(items);\n  return [...set];\n}\n\nasync function registerMissingDevicesAsync(\n  context: RequestContext,\n  udids: string[]\n): Promise<Device[]> {\n  const allIosProfileDevices = await Device.getAllIOSProfileDevicesAsync(context);\n  const alreadyAdded = allIosProfileDevices.filter(device =>\n    udids.includes(device.attributes.udid)\n  );\n  const alreadyAddedUdids = alreadyAdded.map(i => i.attributes.udid);\n\n  await Promise.all(\n    udids.map(async udid => {\n      if (!alreadyAddedUdids.includes(udid)) {\n        const device = await Device.createAsync(context, {\n          name: 'iOS Device (added by Expo)',\n          udid,\n        });\n        alreadyAdded.push(device);\n      }\n    })\n  );\n\n  return alreadyAdded;\n}\n\nasync function findProfileByBundleIdAsync(\n  context: RequestContext,\n  bundleId: string,\n  certSerialNumber: string\n): Promise<{\n  profile: Profile | null;\n  didUpdate: boolean;\n}> {\n  const expoProfiles = (await getProfilesForBundleIdAsync(context, bundleId)).filter(profile => {\n    return (\n      profile.attributes.profileType === ProfileType.IOS_APP_ADHOC &&\n      profile.attributes.name.startsWith('*[expo]') &&\n      profile.attributes.profileState !== ProfileState.EXPIRED\n    );\n  });\n\n  const expoProfilesWithCertificate: Profile[] = [];\n  // find profiles associated with our development cert\n  for (const profile of expoProfiles) {\n    const certificates = await profile.getCertificatesAsync();\n    if (certificates.some(cert => cert.attributes.serialNumber === certSerialNumber)) {\n      expoProfilesWithCertificate.push(profile);\n    }\n  }\n\n  if (expoProfilesWithCertificate) {\n    // there is an expo managed profile with our desired certificate\n    // return the profile that will be valid for the longest duration\n    return {\n      profile: expoProfilesWithCertificate.sort(sortByExpiration)[\n        expoProfilesWithCertificate.length - 1\n      ],\n      didUpdate: false,\n    };\n  } else if (expoProfiles) {\n    // there is an expo managed profile, but it doesn't have our desired certificate\n    // append the certificate and update the profile\n    const distributionCertificate = await getDistributionCertificateAync(context, certSerialNumber);\n    if (!distributionCertificate) {\n      throw new CommandError(`Certificate for serial number \"${certSerialNumber}\" does not exist`);\n    }\n    const profile = expoProfiles.sort(sortByExpiration)[expoProfiles.length - 1];\n    profile.attributes.certificates = [distributionCertificate];\n    return { profile: await profile.regenerateAsync(), didUpdate: true };\n  }\n\n  // there is no valid provisioning profile available\n  return { profile: null, didUpdate: false };\n}\n\nfunction sortByExpiration(a: Profile, b: Profile): number {\n  return (\n    new Date(a.attributes.expirationDate).getTime() -\n    new Date(b.attributes.expirationDate).getTime()\n  );\n}\n\nasync function findProfileByIdAsync(\n  context: RequestContext,\n  profileId: string,\n  bundleId: string\n): Promise<Profile | null> {\n  let profiles = await getProfilesForBundleIdAsync(context, bundleId);\n  profiles = profiles.filter(\n    profile => profile.attributes.profileType === ProfileType.IOS_APP_ADHOC\n  );\n  return profiles.find(profile => profile.id === profileId) ?? null;\n}\n\nasync function manageAdHocProfilesAsync(\n  context: RequestContext,\n  {\n    udids,\n    bundleId,\n    certSerialNumber,\n    profileId,\n  }: {\n    udids: string[];\n    bundleId: string;\n    certSerialNumber: string;\n    profileId?: string;\n  }\n): Promise<ProfileResults> {\n  // We register all missing devices on the Apple Developer Portal. They are identified by UDIDs.\n  const devices = await registerMissingDevicesAsync(context, udids);\n\n  let existingProfile: Profile | null;\n  let didUpdate = false;\n\n  if (profileId) {\n    existingProfile = await findProfileByIdAsync(context, profileId, bundleId);\n    // Fail if we cannot find the profile that was specifically requested\n    if (!existingProfile)\n      throw new CommandError(\n        `Could not find profile with profile id \"${profileId}\" for bundle id \"${bundleId}\"`\n      );\n  } else {\n    // If no profile id is passed, try to find a suitable provisioning profile for the App ID.\n    const results = await findProfileByBundleIdAsync(context, bundleId, certSerialNumber);\n    existingProfile = results.profile;\n    didUpdate = results.didUpdate;\n  }\n\n  if (existingProfile) {\n    // We need to verify whether the existing profile includes all user's devices.\n    let deviceUdidsInProfile =\n      existingProfile?.attributes?.devices?.map?.(i => i.attributes.udid) ?? [];\n    deviceUdidsInProfile = uniqueItems(deviceUdidsInProfile.filter(Boolean));\n    const allDeviceUdids = uniqueItems(udids);\n    const hasEqualUdids =\n      deviceUdidsInProfile.length === allDeviceUdids.length &&\n      deviceUdidsInProfile.every(udid => allDeviceUdids.includes(udid));\n    if (hasEqualUdids && existingProfile.isValid()) {\n      const result: ProfileResults = {\n        profileName: existingProfile?.attributes?.name,\n        provisioningProfileId: existingProfile?.id,\n        provisioningProfile: existingProfile?.attributes.profileContent,\n      };\n      if (didUpdate) {\n        result.didUpdate = true;\n      }\n\n      return result;\n    }\n    // We need to add new devices to the list and create a new provisioning profile.\n    existingProfile.attributes.devices = devices;\n    await existingProfile.regenerateAsync();\n\n    const updatedProfile = (await findProfileByBundleIdAsync(context, bundleId, certSerialNumber))\n      .profile;\n    if (!updatedProfile) {\n      throw new CommandError(\n        `Failed to locate updated profile for bundle identifier \"${bundleId}\" and serial number \"${certSerialNumber}\"`\n      );\n    }\n    return {\n      didUpdate: true,\n      profileName: updatedProfile.attributes.name,\n      provisioningProfileId: updatedProfile.id,\n      provisioningProfile: updatedProfile.attributes.profileContent,\n    };\n  }\n\n  // No existing profile...\n\n  // We need to find user's distribution certificate to make a provisioning profile for it.\n  const distributionCertificate = await getDistributionCertificateAync(context, certSerialNumber);\n\n  if (!distributionCertificate) {\n    // If the distribution certificate doesn't exist, the user must have deleted it, we can't do anything here :(\n    throw new CommandError(\n      `No distribution certificate for serial number \"${certSerialNumber}\" is available to make a provisioning profile against`\n    );\n  }\n  const bundleIdItem = await getBundleIdForIdentifierAsync(context, bundleId);\n  // If the provisioning profile for the App ID doesn't exist, we just need to create a new one!\n  const newProfile = await Profile.createAsync(context, {\n    bundleId: bundleIdItem.id,\n    // apple drops [ if its the first char (!!),\n    name: `*[expo] ${bundleId} AdHoc ${Date.now()}`,\n    certificates: [distributionCertificate.id],\n    devices: devices.map(device => device.id),\n    profileType: ProfileType.IOS_APP_ADHOC,\n  });\n\n  return {\n    didUpdate: true,\n    didCreate: true,\n    profileName: newProfile.attributes.name,\n    provisioningProfileId: newProfile.id,\n    provisioningProfile: newProfile.attributes.profileContent,\n  };\n}\n\nasync function createOrReuseAdhocProvisioningProfileAsync(\n  authCtx: AppleCtx,\n  udids: string[],\n  bundleIdentifier: string,\n  distCertSerialNumber: string\n): Promise<ProvisioningProfile> {\n  const spinner = ora(`Handling Apple ad hoc provisioning profiles`).start();\n  try {\n    const context = getRequestContext(authCtx);\n    const {\n      didUpdate,\n      didCreate,\n      profileName,\n      ...adhocProvisioningProfile\n    } = await manageAdHocProfilesAsync(context, {\n      udids,\n      bundleId: bundleIdentifier,\n      certSerialNumber: distCertSerialNumber,\n    });\n\n    if (didCreate) {\n      spinner.succeed(`Created new profile: ${profileName}`);\n    } else if (didUpdate) {\n      spinner.succeed(`Updated existing profile: ${profileName}`);\n    } else {\n      spinner.succeed(`Used existing profile: ${profileName}`);\n    }\n\n    return {\n      ...adhocProvisioningProfile,\n      teamId: authCtx.team.id,\n      teamName: authCtx.team.name,\n    };\n  } catch (error: any) {\n    spinner.fail(`Failed to handle Apple profiles`);\n    throw error;\n  }\n}\n\nexport class ProvisioningProfileAdhocManager {\n  constructor(public ctx: AppleCtx) {}\n\n  async createOrReuse(\n    udids: string[],\n    bundleIdentifier: string,\n    distCertSerialNumber: string\n  ): Promise<ProvisioningProfile> {\n    return createOrReuseAdhocProvisioningProfileAsync(\n      this.ctx,\n      udids,\n      bundleIdentifier,\n      distCertSerialNumber\n    );\n  }\n}\n"],"mappings":"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"}