{"version":3,"file":"fetchAndroidHashesAsync.js","names":["actionAsync","projectRoot","options","ctx","Context","init","nonInteractive","parent","outputPath","path","resolve","manifest","slug","assertSlug","experienceName","projectOwner","view","DownloadKeystore","quiet","runCredentialsManager","keystore","android","fetchKeystore","AndroidCredentials","logKeystoreHashes","keystorePath","keystorePassword","keyAlias","keyPassword","Log","log","warn","fs","remove"],"sources":["../../../src/commands/fetch/fetchAndroidHashesAsync.ts"],"sourcesContent":["import * as fs from 'fs-extra';\nimport * as path from 'path';\nimport { AndroidCredentials } from 'xdl';\n\nimport { Context } from '../../credentials';\nimport { runCredentialsManager } from '../../credentials/route';\nimport { DownloadKeystore } from '../../credentials/views/AndroidKeystore';\nimport Log from '../../log';\nimport { assertSlug, Options } from './utils';\n\nexport async function actionAsync(projectRoot: string, options: Options): Promise<void> {\n  const ctx = new Context();\n  await ctx.init(projectRoot, {\n    nonInteractive: options.parent?.nonInteractive,\n  });\n  const outputPath = path.resolve(projectRoot, `${ctx.manifest.slug}.tmp.jks`);\n  try {\n    assertSlug(ctx.manifest.slug);\n    const experienceName = `@${ctx.projectOwner}/${ctx.manifest.slug}`;\n    const view = new DownloadKeystore(experienceName, {\n      outputPath,\n      quiet: true,\n    });\n    await runCredentialsManager(ctx, view);\n    const keystore = await ctx.android.fetchKeystore(experienceName);\n\n    if (keystore) {\n      await AndroidCredentials.logKeystoreHashes({\n        keystorePath: outputPath,\n        keystorePassword: keystore.keystorePassword,\n        keyAlias: keystore.keyAlias,\n        keyPassword: keystore.keyPassword,\n      });\n      Log.log(\n        `\\nNote: if you are using Google Play signing, this app will be signed with a different key after publishing to the store, and you'll need to use the hashes displayed in the Google Play console.`\n      );\n    } else {\n      Log.warn('There is no valid Keystore defined for this app');\n    }\n  } finally {\n    await fs.remove(outputPath);\n  }\n}\n"],"mappings":";;;;;;AAAA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAEA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAA8C;AAAA;AAAA;AAEvC,eAAeA,WAAW,CAACC,WAAmB,EAAEC,OAAgB,EAAiB;EAAA;EACtF,MAAMC,GAAG,GAAG,KAAIC,sBAAO,GAAE;EACzB,MAAMD,GAAG,CAACE,IAAI,CAACJ,WAAW,EAAE;IAC1BK,cAAc,qBAAEJ,OAAO,CAACK,MAAM,oDAAd,gBAAgBD;EAClC,CAAC,CAAC;EACF,MAAME,UAAU,GAAGC,IAAI,GAACC,OAAO,CAACT,WAAW,EAAG,GAAEE,GAAG,CAACQ,QAAQ,CAACC,IAAK,UAAS,CAAC;EAC5E,IAAI;IACF,IAAAC,mBAAU,EAACV,GAAG,CAACQ,QAAQ,CAACC,IAAI,CAAC;IAC7B,MAAME,cAAc,GAAI,IAAGX,GAAG,CAACY,YAAa,IAAGZ,GAAG,CAACQ,QAAQ,CAACC,IAAK,EAAC;IAClE,MAAMI,IAAI,GAAG,KAAIC,mCAAgB,EAACH,cAAc,EAAE;MAChDN,UAAU;MACVU,KAAK,EAAE;IACT,CAAC,CAAC;IACF,MAAM,IAAAC,8BAAqB,EAAChB,GAAG,EAAEa,IAAI,CAAC;IACtC,MAAMI,QAAQ,GAAG,MAAMjB,GAAG,CAACkB,OAAO,CAACC,aAAa,CAACR,cAAc,CAAC;IAEhE,IAAIM,QAAQ,EAAE;MACZ,MAAMG,yBAAkB,CAACC,iBAAiB,CAAC;QACzCC,YAAY,EAAEjB,UAAU;QACxBkB,gBAAgB,EAAEN,QAAQ,CAACM,gBAAgB;QAC3CC,QAAQ,EAAEP,QAAQ,CAACO,QAAQ;QAC3BC,WAAW,EAAER,QAAQ,CAACQ;MACxB,CAAC,CAAC;MACFC,cAAG,CAACC,GAAG,CACJ,mMAAkM,CACpM;IACH,CAAC,MAAM;MACLD,cAAG,CAACE,IAAI,CAAC,iDAAiD,CAAC;IAC7D;EACF,CAAC,SAAS;IACR,MAAMC,EAAE,GAACC,MAAM,CAACzB,UAAU,CAAC;EAC7B;AACF"}