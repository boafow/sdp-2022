{"version":3,"file":"validateDependenciesVersions.js","names":["validateDependenciesVersionsAsync","projectRoot","exp","pkg","fixDependencies","Versions","gteSdkVersion","bundledNativeModules","assert","sdkVersion","getBundledNativeModulesAsync","Log","warn","chalk","bold","packagesToCheck","getPackagesToCheck","dependencies","packageVersions","resolvePackageVersionsAsync","incorrectDeps","findIncorrectDependencies","length","forEach","packageName","expectedVersionOrRange","actualVersion","underline","actionAsync","map","dep","inverse","dependencyNames","Object","keys","result","dependencyName","push","packages","packageVersionsFromPackageJSON","Promise","all","getPackageVersionAsync","reduce","acc","idx","packageJsonPath","resolveFrom","error","code","message","match","CommandError","packageJson","JsonFile","readAsync","version","semver","intersects"],"sources":["../../../src/commands/utils/validateDependenciesVersions.ts"],"sourcesContent":["import { ExpoConfig, PackageJSONConfig } from '@expo/config';\nimport JsonFile from '@expo/json-file';\nimport assert from 'assert';\nimport chalk from 'chalk';\nimport resolveFrom from 'resolve-from';\nimport semver from 'semver';\nimport { Versions } from 'xdl';\n\nimport CommandError from '../../CommandError';\nimport Log from '../../log';\nimport { actionAsync } from '../installAsync';\nimport { BundledNativeModules, getBundledNativeModulesAsync } from './bundledNativeModules';\n\nexport async function validateDependenciesVersionsAsync(\n  projectRoot: string,\n  exp: Pick<ExpoConfig, 'sdkVersion'>,\n  pkg: PackageJSONConfig,\n  fixDependencies: boolean = false\n): Promise<boolean> {\n  // expo package for SDK < 33.0.0 does not have bundledNativeModules.json\n  if (!Versions.gteSdkVersion(exp, '33.0.0')) {\n    return false;\n  }\n\n  let bundledNativeModules: BundledNativeModules | null = null;\n  try {\n    assert(exp.sdkVersion);\n    bundledNativeModules = await getBundledNativeModulesAsync(\n      projectRoot,\n      // sdkVersion is defined here because we ran the >= 33.0.0 check before\n      exp.sdkVersion\n    );\n  } catch {\n    Log.warn(\n      `Your project uses Expo SDK version >= 33.0.0, but the ${chalk.bold(\n        'expo'\n      )} package version seems to be older.`\n    );\n    return false;\n  }\n\n  // intersection of packages from package.json and bundled native modules\n  const packagesToCheck = getPackagesToCheck(pkg.dependencies, bundledNativeModules);\n  // read package versions from the file system (node_modules)\n  const packageVersions = await resolvePackageVersionsAsync(projectRoot, packagesToCheck);\n  // find incorrect dependencies by comparing the actual package versions with the bundled native module version ranges\n  const incorrectDeps = findIncorrectDependencies(packageVersions, bundledNativeModules);\n\n  if (incorrectDeps.length > 0) {\n    Log.warn('Some dependencies are incompatible with the installed expo package version:');\n    incorrectDeps.forEach(({ packageName, expectedVersionOrRange, actualVersion }) => {\n      Log.warn(\n        ` - ${chalk.underline(packageName)} - expected version: ${chalk.underline(\n          expectedVersionOrRange\n        )} - actual version installed: ${chalk.underline(actualVersion)}`\n      );\n    });\n    if (fixDependencies) {\n      await actionAsync(\n        incorrectDeps.map(dep => dep.packageName),\n        {}\n      );\n    } else {\n      Log.warn(\n        'Your project may not work correctly until you install the correct versions of the packages.\\n' +\n          `To install the correct versions of these packages, please run: ${chalk.inverse(\n            'expo doctor --fix-dependencies'\n          )},\\n` +\n          `or install individual packages by running ${chalk.inverse(\n            'expo install [package-name ...]'\n          )}`\n      );\n    }\n\n    return false;\n  }\n  return true;\n}\n\nfunction getPackagesToCheck(\n  dependencies: Record<string, string> | null | undefined,\n  bundledNativeModules: BundledNativeModules\n): string[] {\n  const dependencyNames = Object.keys(dependencies ?? {});\n  const result: string[] = [];\n  for (const dependencyName of dependencyNames) {\n    if (dependencyName in bundledNativeModules) {\n      result.push(dependencyName);\n    }\n  }\n  return result;\n}\n\nasync function resolvePackageVersionsAsync(\n  projectRoot: string,\n  packages: string[]\n): Promise<Record<string, string>> {\n  const packageVersionsFromPackageJSON = await Promise.all(\n    packages.map(packageName => getPackageVersionAsync(projectRoot, packageName))\n  );\n  return packages.reduce((acc, packageName, idx) => {\n    acc[packageName] = packageVersionsFromPackageJSON[idx];\n    return acc;\n  }, {} as Record<string, string>);\n}\n\nasync function getPackageVersionAsync(projectRoot: string, packageName: string): Promise<string> {\n  let packageJsonPath: string | undefined;\n  try {\n    packageJsonPath = resolveFrom(projectRoot, `${packageName}/package.json`);\n  } catch (error: any) {\n    // This is a workaround for packages using `exports`. If this doesn't\n    // include `package.json`, we have to use the error message to get the location.\n    if (error.code === 'ERR_PACKAGE_PATH_NOT_EXPORTED') {\n      packageJsonPath = error.message.match(/(\"exports\"|defined) in (.*)$/i)?.[2];\n    }\n  }\n  if (!packageJsonPath) {\n    throw new CommandError(\n      `\"${packageName}\" is added as a dependency in your project's package.json but it doesn't seem to be installed. Please run \"yarn\" or \"npm install\" to fix this issue.`\n    );\n  }\n  const packageJson = await JsonFile.readAsync<BundledNativeModules>(packageJsonPath);\n  return packageJson.version;\n}\n\ninterface IncorrectDependency {\n  packageName: string;\n  expectedVersionOrRange: string;\n  actualVersion: string;\n}\n\nfunction findIncorrectDependencies(\n  packageVersions: Record<string, string>,\n  bundledNativeModules: BundledNativeModules\n): IncorrectDependency[] {\n  const packages = Object.keys(packageVersions);\n  const incorrectDeps: IncorrectDependency[] = [];\n  for (const packageName of packages) {\n    const expectedVersionOrRange = bundledNativeModules[packageName];\n    const actualVersion = packageVersions[packageName];\n    if (\n      typeof expectedVersionOrRange === 'string' &&\n      !semver.intersects(expectedVersionOrRange, actualVersion)\n    ) {\n      incorrectDeps.push({\n        packageName,\n        expectedVersionOrRange,\n        actualVersion,\n      });\n    }\n  }\n  return incorrectDeps;\n}\n"],"mappings":"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"}