{"version":3,"file":"ThirdParty.js","names":["getManifest","publicUrl","platform","req","url","method","headers","Accept","exp","resp","axios","request","data","e","XDLError","toString","_extractManifest","expOrArray","Array","isArray","sdkVersions","Versions","versionsAsync","i","length","manifestCandidate","sdkVersion","versionObj","isDeprecated","supportedVersions","Object","keys","JSON","stringify"],"sources":["../src/ThirdParty.ts"],"sourcesContent":["import axios, { AxiosRequestConfig } from 'axios';\n\nimport { Versions, XDLError } from './internal';\n\nexport async function getManifest(\n  publicUrl: string,\n  { platform = 'all' }: { platform?: 'android' | 'ios' | 'all' } = {}\n) {\n  const req: AxiosRequestConfig = {\n    url: publicUrl,\n    method: 'get',\n    headers: { Accept: 'application/expo+json,application/json' },\n  };\n\n  let exp;\n  try {\n    const resp = await axios.request(req);\n    exp = resp.data;\n  } catch (e: any) {\n    throw new XDLError(\n      'INVALID_MANIFEST',\n      `Unable to fetch manifest from ${publicUrl}. ` + e.toString()\n    );\n  }\n  exp = await _extractManifest(exp, publicUrl);\n  if (exp.platform !== platform && platform !== 'all') {\n    throw new XDLError(\n      'INVALID_MANIFEST',\n      `Manifest from ${publicUrl} is not compatible with the ${platform} platform`\n    );\n  }\n  return exp;\n}\n\n// Third party publicUrls can return an array of manifests\n// We need to choose the first compatible one\nasync function _extractManifest(expOrArray: any, publicUrl: string) {\n  // if its not an array, assume it was a single manifest obj\n  if (!Array.isArray(expOrArray)) {\n    return expOrArray;\n  }\n\n  const { sdkVersions } = await Versions.versionsAsync();\n  for (let i = 0; i < expOrArray.length; i++) {\n    const manifestCandidate = expOrArray[i];\n    const sdkVersion = manifestCandidate.sdkVersion;\n    if (!sdkVersion) {\n      continue;\n    }\n    const versionObj = sdkVersions[sdkVersion];\n    if (!versionObj) {\n      continue;\n    }\n\n    const isDeprecated = versionObj.isDeprecated || false;\n    if (!isDeprecated) {\n      return manifestCandidate;\n    }\n  }\n  const supportedVersions = Object.keys(sdkVersions);\n  throw new XDLError(\n    'INVALID_MANIFEST',\n    `No compatible manifest found at ${publicUrl}. Please use one of the SDK versions supported: ${JSON.stringify(\n      supportedVersions\n    )}`\n  );\n}\n"],"mappings":";;;;;;AAAA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAEA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAAgD;AAEzC,eAAeA,WAAW,CAC/BC,SAAiB,EACjB;EAAEC,QAAQ,GAAG;AAAgD,CAAC,GAAG,CAAC,CAAC,EACnE;EACA,MAAMC,GAAuB,GAAG;IAC9BC,GAAG,EAAEH,SAAS;IACdI,MAAM,EAAE,KAAK;IACbC,OAAO,EAAE;MAAEC,MAAM,EAAE;IAAyC;EAC9D,CAAC;EAED,IAAIC,GAAG;EACP,IAAI;IACF,MAAMC,IAAI,GAAG,MAAMC,gBAAK,CAACC,OAAO,CAACR,GAAG,CAAC;IACrCK,GAAG,GAAGC,IAAI,CAACG,IAAI;EACjB,CAAC,CAAC,OAAOC,CAAM,EAAE;IACf,MAAM,KAAIC,oBAAQ,EAChB,kBAAkB,EACjB,iCAAgCb,SAAU,IAAG,GAAGY,CAAC,CAACE,QAAQ,EAAE,CAC9D;EACH;EACAP,GAAG,GAAG,MAAMQ,gBAAgB,CAACR,GAAG,EAAEP,SAAS,CAAC;EAC5C,IAAIO,GAAG,CAACN,QAAQ,KAAKA,QAAQ,IAAIA,QAAQ,KAAK,KAAK,EAAE;IACnD,MAAM,KAAIY,oBAAQ,EAChB,kBAAkB,EACjB,iBAAgBb,SAAU,+BAA8BC,QAAS,WAAU,CAC7E;EACH;EACA,OAAOM,GAAG;AACZ;;AAEA;AACA;AACA,eAAeQ,gBAAgB,CAACC,UAAe,EAAEhB,SAAiB,EAAE;EAClE;EACA,IAAI,CAACiB,KAAK,CAACC,OAAO,CAACF,UAAU,CAAC,EAAE;IAC9B,OAAOA,UAAU;EACnB;EAEA,MAAM;IAAEG;EAAY,CAAC,GAAG,MAAMC,oBAAQ,CAACC,aAAa,EAAE;EACtD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,UAAU,CAACO,MAAM,EAAED,CAAC,EAAE,EAAE;IAC1C,MAAME,iBAAiB,GAAGR,UAAU,CAACM,CAAC,CAAC;IACvC,MAAMG,UAAU,GAAGD,iBAAiB,CAACC,UAAU;IAC/C,IAAI,CAACA,UAAU,EAAE;MACf;IACF;IACA,MAAMC,UAAU,GAAGP,WAAW,CAACM,UAAU,CAAC;IAC1C,IAAI,CAACC,UAAU,EAAE;MACf;IACF;IAEA,MAAMC,YAAY,GAAGD,UAAU,CAACC,YAAY,IAAI,KAAK;IACrD,IAAI,CAACA,YAAY,EAAE;MACjB,OAAOH,iBAAiB;IAC1B;EACF;EACA,MAAMI,iBAAiB,GAAGC,MAAM,CAACC,IAAI,CAACX,WAAW,CAAC;EAClD,MAAM,KAAIN,oBAAQ,EAChB,kBAAkB,EACjB,mCAAkCb,SAAU,mDAAkD+B,IAAI,CAACC,SAAS,CAC3GJ,iBAAiB,CACjB,EAAC,CACJ;AACH"}