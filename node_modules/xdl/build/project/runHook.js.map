{"version":3,"file":"runHook.js","names":["requireFromProject","projectRoot","modulePath","fullPath","resolveFrom","decache","require","prepareHooks","hooks","hookType","validHooks","forEach","hook","file","fn","logger","global","error","_fn","push","undefined","length","XDLError","runHook","hookOptions","result","config","then","info","quiet"],"sources":["../../src/project/runHook.ts"],"sourcesContent":["import { ExpoConfig, Hook, HookArguments, HookType } from '@expo/config';\nimport decache from 'decache';\nimport resolveFrom from 'resolve-from';\n\nimport { Logger as logger, XDLError } from '../internal';\n\nexport type LoadedHook = Hook & {\n  _fn: (input: HookArguments) => any;\n};\n\nfunction requireFromProject(projectRoot: string, modulePath: string) {\n  try {\n    const fullPath = resolveFrom(projectRoot, modulePath);\n    // Clear the require cache for this module so get a fresh version of it\n    // without requiring the user to restart Expo CLI\n    decache(fullPath);\n    return require(fullPath);\n  } catch {\n    return null;\n  }\n}\n\nexport function prepareHooks(hooks: ExpoConfig['hooks'], hookType: HookType, projectRoot: string) {\n  const validHooks: LoadedHook[] = [];\n\n  if (hooks) {\n    if (hooks[hookType]) {\n      hooks[hookType]!.forEach((hook: any) => {\n        const { file } = hook;\n        const fn = requireFromProject(projectRoot, file);\n        if (typeof fn !== 'function') {\n          logger.global.error(\n            `Unable to load ${hookType} hook: '${file}'. The module does not export a function.`\n          );\n        } else {\n          hook._fn = fn;\n          validHooks.push(hook);\n        }\n      });\n    }\n\n    if (hooks[hookType] !== undefined && validHooks.length !== hooks[hookType]?.length) {\n      throw new XDLError(\n        'HOOK_INITIALIZATION_ERROR',\n        `Please fix your ${hookType} hook configuration`\n      );\n    }\n  }\n\n  return validHooks;\n}\n\nexport async function runHook(hook: LoadedHook, hookOptions: Omit<HookArguments, 'config'>) {\n  let result = hook._fn({\n    config: hook.config,\n    ...hookOptions,\n  });\n\n  // If it's a promise, wait for it to resolve\n  if (result && result.then) {\n    result = await result;\n  }\n\n  if (result) {\n    logger.global.info({ quiet: true }, result);\n  }\n}\n"],"mappings":";;;;;;;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAEA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAAyD;AAMzD,SAASA,kBAAkB,CAACC,WAAmB,EAAEC,UAAkB,EAAE;EACnE,IAAI;IACF,MAAMC,QAAQ,GAAG,IAAAC,sBAAW,EAACH,WAAW,EAAEC,UAAU,CAAC;IACrD;IACA;IACA,IAAAG,kBAAO,EAACF,QAAQ,CAAC;IACjB,OAAOG,OAAO,CAACH,QAAQ,CAAC;EAC1B,CAAC,CAAC,MAAM;IACN,OAAO,IAAI;EACb;AACF;AAEO,SAASI,YAAY,CAACC,KAA0B,EAAEC,QAAkB,EAAER,WAAmB,EAAE;EAChG,MAAMS,UAAwB,GAAG,EAAE;EAEnC,IAAIF,KAAK,EAAE;IAAA;IACT,IAAIA,KAAK,CAACC,QAAQ,CAAC,EAAE;MACnBD,KAAK,CAACC,QAAQ,CAAC,CAAEE,OAAO,CAAEC,IAAS,IAAK;QACtC,MAAM;UAAEC;QAAK,CAAC,GAAGD,IAAI;QACrB,MAAME,EAAE,GAAGd,kBAAkB,CAACC,WAAW,EAAEY,IAAI,CAAC;QAChD,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;UAC5BC,kBAAM,CAACC,MAAM,CAACC,KAAK,CAChB,kBAAiBR,QAAS,WAAUI,IAAK,2CAA0C,CACrF;QACH,CAAC,MAAM;UACLD,IAAI,CAACM,GAAG,GAAGJ,EAAE;UACbJ,UAAU,CAACS,IAAI,CAACP,IAAI,CAAC;QACvB;MACF,CAAC,CAAC;IACJ;IAEA,IAAIJ,KAAK,CAACC,QAAQ,CAAC,KAAKW,SAAS,IAAIV,UAAU,CAACW,MAAM,yBAAKb,KAAK,CAACC,QAAQ,CAAC,oDAAf,gBAAiBY,MAAM,GAAE;MAClF,MAAM,KAAIC,oBAAQ,EAChB,2BAA2B,EAC1B,mBAAkBb,QAAS,qBAAoB,CACjD;IACH;EACF;EAEA,OAAOC,UAAU;AACnB;AAEO,eAAea,OAAO,CAACX,IAAgB,EAAEY,WAA0C,EAAE;EAC1F,IAAIC,MAAM,GAAGb,IAAI,CAACM,GAAG,CAAC;IACpBQ,MAAM,EAAEd,IAAI,CAACc,MAAM;IACnB,GAAGF;EACL,CAAC,CAAC;;EAEF;EACA,IAAIC,MAAM,IAAIA,MAAM,CAACE,IAAI,EAAE;IACzBF,MAAM,GAAG,MAAMA,MAAM;EACvB;EAEA,IAAIA,MAAM,EAAE;IACVV,kBAAM,CAACC,MAAM,CAACY,IAAI,CAAC;MAAEC,KAAK,EAAE;IAAK,CAAC,EAAEJ,MAAM,CAAC;EAC7C;AACF"}