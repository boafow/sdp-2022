{"version":3,"file":"FsCache.js","names":["Cacher","constructor","refresher","filename","ttlMilliseconds","bootstrapFile","path","join","getCacheDir","getAsync","process","env","SKIP_CACHE","mtime","stats","fs","stat","mkdirp","bootstrapContents","readFile","toString","writeFile","Date","fromCache","failedRefresh","getTime","JSON","stringify","e","writeError","parse","readError","Error","clearAsync","unlink","homeDir","os","homedir","XDG_CACHE_HOME","platform"],"sources":["../../src/tools/FsCache.ts"],"sourcesContent":["import fs from 'fs-extra';\nimport os from 'os';\nimport path from 'path';\n\n/*\nA Cacher is used to wrap a fallible or expensive function and to memoize its results on disk\nin case it either fails or we don't need fresh results very often. It stores objects in JSON, and\nparses JSON from disk when returning an object.\n\nIt's constructed with a \"refresher\" callback which will be called for the results, a filename to use\nfor the cache, and an optional TTL and boostrap file. The TTL (in milliseconds) can be used to speed\nup slow calls from the cache (for example checking npm published versions can be very slow). The\nbootstrap file can be used to \"seed\" the cache with a particular value stored in a file.\n\nIf there is a problem calling the refresher function or in performing the cache's disk I/O, errors\nwill be stored in variables on the class. The only times Cacher will throw an exception are if it's\nnot possible to create the cache directory (usually weird home directory permissions), or if getAsync()\nis called but no value can be provided. The latter will only occur if the refresher fails, no cache\nis available on disk (i.e. this is the first call or it has been recently cleared), and bootstrapping\nwas not available (either a bootstrap file wasn't provided or reading/writing failed).\n\nSee src/__tests__/tools/FsCache-test.js for usage examples.\n*/\nclass Cacher<T> {\n  refresher: () => Promise<T>;\n  filename: string;\n  bootstrapFile?: string;\n  ttlMilliseconds: number;\n\n  readError?: any;\n  writeError?: any;\n\n  constructor(\n    refresher: () => Promise<T>,\n    filename: string,\n    ttlMilliseconds?: number,\n    bootstrapFile?: string\n  ) {\n    this.refresher = refresher;\n    this.filename = path.join(getCacheDir(), filename);\n    this.ttlMilliseconds = ttlMilliseconds || 0;\n    this.bootstrapFile = bootstrapFile;\n  }\n\n  async getAsync(): Promise<T> {\n    // Let user opt out of cache for debugging purposes\n    if (process.env.SKIP_CACHE) {\n      return await this.refresher();\n    }\n\n    let mtime: Date;\n    try {\n      const stats = await fs.stat(this.filename);\n      mtime = stats.mtime;\n    } catch {\n      try {\n        await fs.mkdirp(getCacheDir());\n\n        if (this.bootstrapFile) {\n          const bootstrapContents = (await fs.readFile(this.bootstrapFile)).toString();\n\n          await fs.writeFile(this.filename, bootstrapContents, 'utf8');\n        }\n      } catch {\n        // intentional no-op\n      }\n      mtime = new Date(1989, 10, 19);\n    }\n\n    let fromCache: T | null = null;\n    let failedRefresh = null;\n\n    // if mtime + ttl >= now, attempt to fetch the value, otherwise read from disk\n    // alternatively, if ttlMilliseconds is 0 we also update every time, regardless of the times.\n    // this is a workaround for the issue described in https://github.com/expo/expo-cli/issues/1683\n    if (\n      this.ttlMilliseconds === 0 ||\n      new Date().getTime() - mtime.getTime() > this.ttlMilliseconds\n    ) {\n      try {\n        fromCache = await this.refresher();\n\n        try {\n          await fs.writeFile(this.filename, JSON.stringify(fromCache), 'utf8');\n        } catch (e: any) {\n          this.writeError = e;\n          // do nothing, if the refresh succeeded it'll be returned, if the persist failed we don't care\n        }\n      } catch (e: any) {\n        failedRefresh = e;\n      }\n    }\n\n    if (!fromCache) {\n      try {\n        fromCache = JSON.parse(await fs.readFile(this.filename, 'utf8'));\n      } catch (e: any) {\n        this.readError = e;\n        // if this fails then we've exhausted our options and it should remain null\n      }\n    }\n\n    if (fromCache) {\n      return fromCache;\n    } else {\n      if (failedRefresh) {\n        throw new Error(`Unable to perform cache refresh for ${this.filename}: ${failedRefresh}`);\n      } else {\n        throw new Error(`Unable to read ${this.filename}. ${this.readError || ''}`);\n      }\n    }\n  }\n\n  async clearAsync(): Promise<void> {\n    try {\n      await fs.unlink(this.filename);\n    } catch (e: any) {\n      this.writeError = e;\n    }\n  }\n}\n\nfunction getCacheDir(): string {\n  const homeDir = os.homedir();\n  if (process.env.XDG_CACHE_HOME) {\n    return process.env.XDG_CACHE_HOME;\n  } else if (process.platform === 'win32') {\n    return path.join(homeDir, 'AppData', 'Local', 'Expo');\n  } else if (process.platform === 'darwin') {\n    // too many mac users have broken permissions on their ~/.cache directory\n    return path.join(homeDir, '.expo', 'cache');\n  } else {\n    return path.join(homeDir, '.cache', 'expo');\n  }\n}\n\nexport { Cacher, getCacheDir };\n"],"mappings":"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"}